var https = require('https'),
    nacl_factory = require('js-nacl'),
    util = require('util'),
    fs = require('fs'),
    mongoose = require('mongoose'),
    ds = require('../models/DataSourceMongoose.js');
var AxolotlState = mongoose.model('AxolotlState');

var DataSource = ds.DataSource;
/**
 * Create a database connection to use globally throughout the program.
 */
global.db_conn = mongoose.connect('mongodb://localhost/keys');

/**
 * Create a global NaCl instance.
 */
global.nacl = nacl_factory.instantiate();

/*
 * Require our own libraries.
 */
var token = require("../libs/token.js"),
myutil = require("../libs/util.js"),
axolotl = require("../libs/axolotl.js");

/**
 * Declare a more meaningful name for crypto_box_keypair in this context.
 */

var newDHParam = nacl.crypto_box_keypair;
var stateAlice;
var ID_token;
var bobID;

/*
Test Client:
1.) get ID token
2.) exchange Keys with Diffie-Hellman
3.) exchange Prekeys

*/


function getOptions(ignoreCert, headers)      //set server IP for testing and CertIgnore
{
    var options = {  
      hostname: '127.0.0.1',
      port: 8888,
      path: '/',
      method: 'GET',
      headers: headers,
      rejectUnauthorized: true,      
      requestCert: true,
      agent: true        
    };    
    
    if (ignoreCert == true) 
    {
        options["rejectUnauthorized"] = false;      //ignore self-signed cert        
        options["agent"] = false;
    }
    
    return options
}

function getHeaders(userString, ClientLevel)   //set headers for https request
{
    var headers = 
    {
      'user-agent': ClientLevel,
      'Content-Type': 'application/json',
      'Content-Length': userString.length
    };
    
    return headers    
}

//                    1.) get ID token

/*
the server accepts this message format:

payload = 
    {
        "type" : "IDREQ"
    };

the response contains an identification token which is used for later communication:

{ info: 
   { expires: 'TTL',
     nonce: 'hex' },
  mac: 'hex' }

*/

function requestID(callback)     
{

    var payload = 
    {
        "type" : "IDREQ"
    };

    var userString = JSON.stringify(payload);

    var headers = getHeaders(userString, 'IDRequestClient');   //set Client and build https Headers

    var options = getOptions(true, headers);      //do not ask for certificate validation

    var req = https.request(options, function(res)     //callback at result
    {
        res.on('data', function(d)        //store response content (ID token)
        {
            ID_token = d;
        });
        res.on('end', function () 
        {             
            console.log("STATUS: " + res.statusCode);
            ID_token = JSON.parse(ID_token);    
            console.log(ID_token
            );   
            callback(ID_token);                     //start KeyExchange Routine
        })
    });
    req.end();

    req.on('error', function(e) 
    {
        console.error(e);
    });

    // write data to request body
    req.write(userString);
    req.end();
}


//                        2.) exchange Keys with Diffie-Hellman

/*

the requestID() callback method builds a message for the key exchange procedure (Diffie-Hellman).
The server accepts this message format:
    {
        "type" : "KEYXC",
        "id_token" : ID_token,
        "keys" : aliceKeyExchangeMsg
    };
    
An ID_token is obtained through a previous requestID() call.

The public keys get generated by newDHParam() and their hex values are used to build the message.

The server sends back his on KeyExchange message, which contains an id and two emphemeral keys

{ id: 'xyz',
  eph0: 'xyz',
  eph1: 'xyz' }


The axolotl state is also updated and a test message send

*/

function exchangeKeys(ID_token)   //call requestID() and start KeyExchange Routine at callback
{
    console.log('[+] Params generated - Building KeyExchangeMsg');  

    var aliceParams =         //generate Diffie-Hellman Params for KeyExchange
    {
        'id' : newDHParam(),
        'eph0' : newDHParam()   
    } 
    var aliceKeyExchangeMsg =               //build message with public id and ephemeral key
    {
        'id' : nacl.to_hex(aliceParams['id']['boxPk']),
        'eph0' : nacl.to_hex(aliceParams['eph0']['boxPk'])
    }     

    var payload = 
    {
        "type" : "KEYXC",
        "id_token" : ID_token,
        "keys" : aliceKeyExchangeMsg
    };

    var userString = JSON.stringify(payload);

    var headers = getHeaders(userString, 'KeyExchangeClient');    //set Client and build https Headers

    var options = getOptions(true, headers);      //do not ask for certificate validation

    var keyExchangeMessage = "";
    
    var req = https.request(options, function(res)    //send KeyExchange message
    {
        res.on('data', function(d)   //get response from Server
        {
            keyExchangeMessage += d;
        });
        res.on('end', function () 
        {
            console.log("STATUS: " + res.statusCode);
            if (res.statusCode == 200) 
            {
                console.log("\n[+] KeyExchangeMessage received from Server\n");
            }
            
            keyExchangeMessage = JSON.parse(keyExchangeMessage);          
            
            console.log('typeof(id):', typeof(keyExchangeMessage.id));
            
            console.log('key exchange message from Bob:', keyExchangeMessage);
            
            bobID = keyExchangeMessage['id'];
            
            axolotl.keyAgreementAlice(aliceParams, keyExchangeMessage, function(err, keys)    //calculate secret using own Diffie-Hellman params and received
            {
                if (err) 
                {        
                    throw new Error('Apparently Alice could not finish the key agreement.');
                } else 
                {
                    stateAlice = new AxolotlState();                            //set up AxolotlState
                    stateAlice.id_mac = bobID;                
                    updateStateAlice(keys, keyExchangeMessage, aliceParams);    //update State and send test message
                }
            });        
        })
    });

    req.on('error', function(e) 
    {
        console.error(e);
    });

    // write data to request body
    req.write(userString);
    req.end();
}

/*
                                        3.) exchange Prekeys

when the message type field is omitted the server expects an encrypted message, this message may used to send prekeys

payload = 
        {
            "id_token" : ID_token,
            "payload" : ciphertext
        };

the encrypted message contains a type field and a pk or pkreq field

- PKPUT send prekey, pk
- PKREQ request preky, pkreq

- kid is a nonce 
- base a Diffie-Hellman param 

message = {
                "type" : "PKPUT",
                "pk" : {
                    "kid" : kid,
                    "base" : base
                }
            };

*/

function sendMsg(message)
{
    console.log('sending', message);
    console.log('ID for Bob in test client', bobID)
    axolotl.sendMessage(bobID, message, function(err, ciphertext, state) 
    {
        stateAlice = state;     //update state
        
        var result = '';
        
        var payload = 
        {
            "id_token" : ID_token,
            "payload" : ciphertext            //use encrypted message
        };
        var userString = JSON.stringify(payload);
        
        console.log('in sendMessage callback, message:',payload);
        
        var headers = getHeaders(userString, 'SendMsgClient');      //set Client and build https Headers

        var options = getOptions(true, headers);      //do not ask for certificate validation
        
        var req = https.request(options, function(res) 
        {                   
            console.log('request');
            res.on('data', function(d) 
            {
                result += d;
            });

            res.on('end', function () 
            {
                console.log("STATUS: " + res.statusCode);
                console.log('received:', result);
                decryptIncoming(result);                 //decrpyt the encrpyted response
            });

        });

        req.on('error', function(e) 
        {
            console.error(e);
        });
        // write data to request body
        req.write(userString);
        req.end();
    }, true);
}

function updateStateAlice(keysAlice, keyExchangeMsgBob, aliceParams) 
{
    stateAlice.root_key              = keysAlice.rk;
    stateAlice.chain_key_recv        = keysAlice.ck; // Alice is Client. So we set CKr first.
    stateAlice.header_key_recv       = keysAlice.hk;
    stateAlice.next_header_key_send  = keysAlice.nhk0;
    stateAlice.next_header_key_recv  = keysAlice.nhk1;
    stateAlice.dh_identity_key_send  = nacl.to_hex(aliceParams.id.boxSk);
    stateAlice.dh_identity_key_recv  = nacl.to_hex(keyExchangeMsgBob.id);
    stateAlice.dh_ratchet_key_recv   = nacl.to_hex(keyExchangeMsgBob.eph1);
    stateAlice.counter_send = 0;
    stateAlice.counter_recv = 0;
    stateAlice.previous_counter_send = 0;
    stateAlice.ratchet_flag = true;
    
    AxolotlState.remove({ 'id_mac' : bobID }, function()
    {
        stateAlice.save(function(err) {
            if (!err)
                console.log("[+] Alice State updated"); 


            var kid = nacl.to_hex(nacl.crypto_box_random_nonce());
            var base = newDHParam();
            base = nacl.to_hex(base['boxPk']);
            var message = {
                "type" : "PKPUT",
                "pk" : {
                    "kid" : kid,
                    "base" : base
                }
            };
            console.log('Send message now!');
            sendMsg(JSON.stringify(message)); 
        });
    });
}




function decryptIncoming(message) 
{
    message = JSON.parse(message);
    axolotl.recvMessage(bobID, message, function (err, plaintext, state) 
    {
        if (err)
            console.log(err);
        else 
        {
            console.log(plaintext);
        }
    });
}



requestID(exchangeKeys);


























